/* eslint-disable @typescript-eslint/no-inferrable-types */

// NÃ£o utilizar ANY
// Tipos bÃ¡sicos - InferÃªncia de tipos

const nome: string = "vitor";
const idade: number = 30;
const adulto: boolean = true;
const simbolo: symbol = Symbol("symbol");

// Arrays
const arrayDeNumeros: Array<number> = [1, 2, 3];
const arrayDeCaracteres: string[] = ["1", "2", "3"];

// Objetos
// ? Faz com que a chave seja opcional
const pessoa: { nome: string; idade: number; adulto?: boolean } = {
  nome: "vitor",
  adulto: true,
  idade: 30,
};

// FunÃ§Ãµes
function soma(x: number, y: number) {
  return x + y;
}

const soma2: (x: number, y: number) => number = (x, y) => x + y;

// Type Any

function falaOi(msg: any): any {
  return msg;
}

// Pode ser enviado dados de qualquer tipo
// Utilizar apenas em Ãºltimo caso

// Type array
// : Array<T> || T[]

function multipicaArgumento(...args: Array<number>): number {
  return args.reduce((acc, valor) => acc * valor, 1);
}

function contatenaString(...args: string[]): string {
  return args.reduce((acc, valor) => acc + " " + valor);
}

function upperCase(...args: string[]): string[] {
  return args.map((valor) => valor.toUpperCase());
}

// console.log(multipicaArgumento(1, 2, 3, 4));
// console.log(contatenaString("ola", "bom", "dia"));
// console.log(upperCase("ola", "bom", "dia"));

// Type Enum
// Enumerar coisas

enum Cores {
  vermelho, // pode definir qual o valor => vermelho = 10 // se nÃ£o definir => 0
  azul, // 1
  verde, // 2
}

// console.log(Cores);
// console.log(Cores.vermelho);

// Type never
// Nunca vai retornar nada

export function criaerro(): never {
  throw new Error("Algum erro...");
}

// Type null and unefined
// FuncÃµes podem retornar null | undefined propositalmente
// Type script reclama quando a funÃ§Ã£o pode retornar null

function createPerson(
  firstName: string,
  lastName?: string // ? => opcional
): {
  firstName: string;
  lastName?: string; // opcional devido ao fato de que o segundo argumento pode nÃ£o existir
} {
  return { firstName, lastName };
}

// Type object

const objectA = {
  chave: "valor",
};

// objectA.nome = "teste"; nÃ£o consegue pois o tipo jÃ¡ foi inferido

// inferir tipo manualmente

const objectB: {
  readonly chave1: string; // nÃ£o pode ter valor alterado
  chaveb?: string; // ? para tornÃ¡-lo opcional, consegue definir valor posteriomente
  [key: string]: unknown;
} = {
  chave1: "valor1",
};

// Type tuple
// Objetos com chaves fixas

const dadosClientes: [number, string] = [1, "vitor"];

dadosClientes[0] = 100;

// Types void
// FunÃ§Ãµes que nÃ£o retornam nada

function _log(...args: string[]): void {
  // console.log(args.join(" "));
}

_log("eu", "sou", "feliz");

// Type unknownw

let x: unknown;

x = 10;
x = "1";

const y = 100;

// console.log(x + y); // Reclama por quÃª o X nÃ£o Ã© conhecido, requer checagem atentes, aÃ­ permite ðŸ‘€

// Union type
// Uma funcÃ£o que pode retornar mais que um tipo
// Para fazer a uniÃ£o
// FunÃ§Ã£o abaixo considerada mÃ¡ prÃ¡tica

function addOrConcat(x: number | string, y: number | string) {
  // Fazer checagem para nÃ£o dar erro
  if (typeof x == "number" && typeof y == "number") return x + y;
  return `${x}${y}`;
}

// Literal types

let num: 100 = 100; // eslint-disable-line
// num = 120; Erro pois a variÃ¡vel sÃ³ pode valer 100

// outra forma
let numero = 100 as const; // eslint-disable-line
// const numero = 100 => mais fÃ¡cil

// Pode ser usado em funÃ§Ãµes

function escolhaCor(cor: "Vermelho" | "Verde" | "Azul"): string {
  return cor;
}

// Type alias

type CorRgb = "Vermelho" | "Verde" | "Azul";
type CorBw = "Branco" | "Preto";
type Cor = CorBw | CorRgb;
type Idade = number;
type Pessoa = {
  nome: string;
  idade: Idade;
  cor?: Cor;
};

const _pessoa: Pessoa = {
  nome: "vitor",
  idade: 2_0,
};

function setCorFav(pessoa: Pessoa, cor: Cor) {
  return { ...pessoa, cor };
}

// console.log(setCorFav(_pessoa, "Vermelho"));

// Intersection types

type AB = "A" | "B";
type AC = "A" | "C";
type Intersection = AB & AC; // & => AND // InterceÃ§Ã£o dos dois tipos

const pessoa01: Intersection = "A";

// FuncÃµes

type MapStringCallback = (item: string) => string;

function mapString(array: string[], callbackFn: MapStringCallback): string[] {
  const newArray: string[] = [];

  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    newArray.push(callbackFn(item));
  }

  return newArray;
}

const abc = ["a", "b", "c"];

const adcMapped = mapString(abc, (item) => item.toUpperCase());

// console.log(adcMapped);

// Structural typing

type VerifyUserFn = (user: User, sentValue: User) => boolean;
type User = {
  user: string;
  password: string;
};

const VerifyUser: VerifyUserFn = (user, sentValue) => {
  return user.user === sentValue.user && user.password === sentValue.password;
};

// Type assertion

const body = document.querySelector("body");
// pode ser null entÃ£o precisa checar
if (body) body.style.background = "red";

// Ou, usando type assertion

const body01 = document.querySelector("body") as HTMLBodyElement; // Precisa ter a certeza da existÃªncia do elemento
const body02 = document.querySelector("body") as unknown as number; // Inferir outro tipo // NÃ¢o recomendado
